
const getData = (url) =>
new Promise((resolve,reject) =>
    fetch(url) 
    .then(response => response.json())
    .then(json => resolve(json))
    .catch(error => reject(error))
)

// Здесь созданна отдельная фу-ия getData с пара-ом (url) она не явно(нет скобок) возвращает Промис
// а создание нового экз-ра любого объекта- это выражение и мы можем вернуть его не явно из стрел фун-ии
// при создании экз-ра промиса мы передаемв в качестве аргумента колбэк фун-ию с пара-и (resolve,reject)
// внутри колбэк фу-ии мы вызываем fetch,далее мы получаем ответ от сервера -в первом .then! И если
// пришел ответ(не ошибка)то срабатывает второй.then с вызомом resolve мы передаем ей(json)-уже js об-т
// а если пришла ошибка то.catch с reject и передаем ей ошибку
// иными словами мы создали собс-ый промис чтобы обернуть в него вызов используя фу-ию fetch

getData('https://jsonplaceholder.typicode.com/todos/3')
    .then(data => console.log(data))
    .catch(error => console.log(error.message))

// И теперь мы можем использовать фу-ию getData что бы посылать запросы
// в вызове мы в кач-ве аргумента передаем ей (url) адрес по которому хотим обратиться к серверу
// этот вывоз вернет нам промис,который возвращается из стрелочной фу-ии не явно!!!
// и далее мы выполняем опр дей-ия!когда промис исполнится - .then(data => console.log(data))
// и когда возникает ошибка - .catch(error => console.log(error.message))
// и в вызове getData один .then - так как туда уже пришел промис который обработался resolve(json)
// в теле фу-ии,а data будет указывать на то что мы передали (json) в resolve
// и эдентично касаемо ошибки